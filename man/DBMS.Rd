% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/DBMS.R
\name{DBMS}
\alias{DBMS}
\title{Distribution-based metric scaling}
\usage{
DBMS(
  C,
  H,
  Theta = NULL,
  method = Pois,
  param = NULL,
  update_param = TRUE,
  eps_wpcms = 1e-06,
  maxiter = 100,
  verbose_wpcms = FALSE,
  eps_dbms = 1e-06,
  maxepoch = 100,
  verbose_dbms = FALSE
)
}
\arguments{
\item{C}{a square symmetric matrix representing a contact matrix.}

\item{H}{a spline basis matrix, assumed to have orthonormal columns. If not orthonotmal, orthogonalization should be done via QR decomposition prior to running this function.}

\item{Theta}{initialization for spline basis coefficient matrix \eqn{\Theta}. By default, \code{Theta = NULL}, so random initialization is done for this parameter.}

\item{method}{a probabilistic model used for the contact counts. By default, \code{method = Pois}; other options available are \code{HPois}, \code{ZIPois} and \code{NB}.}

\item{param}{a list containing initialization for the nuisance parameters. If \code{param = NULL}, then the default option is used: \itemize{\item for all methods \code{beta = log(mean(C[C>0]))}, i.e. logarithm of the average of non-zero counts; \item for the \code{HPois} and \code{ZIPois} methods \code{p = mean(C == 0)}, i.e. the proportion of zero counts; \item for the \code{NB} method \code{r = 1}.}}

\item{update_param}{logical. If \code{update_param = TRUE}, then the algorithm finds optimal nuisance parameter values using \code{param} values as initialization. If \code{update_param = FALSE}, then the parameters are considered to be fixed at \code{param} values.}

\item{eps_wpcms, eps_dbms}{positive convergence tolerance rates for the inner and outer loops. Default values are \code{eps_wpcms = 1e-6} and \code{eps_dbms = 1e-6}.}

\item{maxiter, maxepoch}{integers corresponding to maximum number of iterations for the inner loop and maximum number of epochs for the outer loop. Default values are \code{maxiter = 100} and \code{maxepoch = 100}.}

\item{verbose_wpcms, verbose_dbms}{logical. If \code{verbose_wpcms = TRUE}, the WPCMS loss after each iteration in the inner loop is printed. If \code{verbose_dbms = TRUE} the DBMS loss after each epoch in the outer loop is printed. Default values are \code{verbose_wpcms = FALSE} and \code{verbose_dbms = FALSE}.}
}
\value{
A list containing the DBMS problem solution:
\itemize{
  \item \code{Theta} -- the matrix of spline parameters.
  \item \code{X} -- the resulting conformation reconstruction.
  \item \code{param} -- the resulting list of the nuisance parameters.
  \item \code{info} -- table with detailed convergence information that can be used ofr plotting.
  \item \code{epoch} -- the total number of epochs.
  \item \code{iter_total} -- the total number of iterations.
  \item \code{loss} -- the resulting value of the DBMS objective.
}
}
\description{
DBMS function calculates the Distribution-based metric scaling solution for a contact matrix \eqn{C} and a spline basis matrix \eqn{H}.
The optimal solution is found via minimizing the negative log-likelihood for a chosen probabilistic model \eqn{C~f(X, \Omega)} w.r.t. 3D conformation \eqn{X} and nuisance parameters \eqn{\Omega} subject to the smooth curve constraint \eqn{X = H\Theta}.
The solution can be calculated via iterating the second order approximation of the objective (outer epoch loop) and applying WPCMS to optimize the obtained quadratic approximation (inner iteration loop).
The spatial coordinates of the resulting reconstruction are presented in \eqn{X}.
There are four models for contact counts available (however, one can implement their own model):
\itemize{
  \item Poisson model \eqn{C~Pois(X, \beta)};
  \item Hurdle Poisson model \eqn{C~HPois(X, \beta, p)}, where \eqn{p} is the mixture weight;
  \item zero-inflated Poisson model \eqn{C~ZIPois(X, \beta, p)}, where \eqn{p} is the probability of extra zeros;
  \item negative binomial \eqn{C~NB(X, \beta, r)}, where \eqn{r} is the overdispersion parameter.
}
For each model the mean parameter \eqn{\Lambda} is linked to the 3D spatial structure via the log-link \deqn{\log(\Lambda) = -D^2(X) + \beta.}{log(\Lambda) = -D^2(X) + \beta.}
Here \eqn{\beta} is the intercept and \eqn{D(X)} refers to the matrix of pairwise distances between the genomic loci.
}
\examples{
data(C)

#create spline basis matrix
H = splines::bs(1:ncol(C), df = 5)

#orthogonalize H using QR decomposition
H = qr.Q(qr(H))

#run the PoisMS approach; optimize beta; print the epoch and iteration convergence progress
DBMS(C, H, verbose_wpcms = TRUE, verbose_dbms = TRUE)

#run the HPoiMS approach; fix beta and p to log of the average contact count and 0.5, respectively
param = list(beta = log(mean(C)), p = 0.5)
DBMS(C, H, method = HPois, param = param, update_param = FALSE)

#run the ZIPoisMS approach; optimize beta and p initializing them to param; print the outer loop convergence progress
DBMS(C, H, method = HPois, param = param, verbose_dbms = TRUE)

#run the NBMS approach; fix beta and r
param = list(beta = log(mean(C)), r = 1)
DBMS(C, H, method = NB, param = param, update_param = FALSE)

}
